#!/usr/bin/env python
import os
import json
from os.path import *

from mplayer import Player, CmdPrefix, PIPE, Step

class InvalidBookException(Exception):
  pass

class FileSkipException(Exception):
  pass

class AudioBook(object):
  def __init__(self,location):
    location = normcase(expanduser(location))
    if not exists(location):
      e = IOError()
      e.errno = 2
      e.strerror = "No such file or directory"
      e.filename = location
      raise e

    self.pstorydatafile = ".pstorydata"

    self.playing = False

    self.position = 0
    
    # A book can either be given as a directory or as a file.
    # If given as a file, start playing there using bookmark if possible.
    # Otherwise the last played file is used using the stored position, or
    # lacking that the first file in the book.
    if isfile(location):
      self.book = dirname(location)
      self.file = basename(location)
    elif isdir(location):
      self.book = location
      files = self.listFiles()
      if len(files)==0:
        raise InvalidBookException("No files in the book.")
      self.file = files[0]
    else:
      raise Exception("Given object exists, but is neither a file nor directory. What is it?")

    # Set up mplayer.
    self.player = Player(stdout=PIPE, stderr=PIPE, autospawn=False)



    ### Beginning of ugly hack. ################################
    baseargs = self.player._base_args

    # "-really-quiet" changed to "-quiet" (needed to spot when mplayer fails to load files.)
    try:
      i = baseargs.index("-really-quiet")
      baseargs = baseargs[:i] + ("-quiet",) + baseargs[i+1:]
    except ValueError:
      pass

    # "-noconfig all" removed all together (we want to use ordinary mplayer config.)
    for i in xrange(0,len(baseargs)-1):
      if baseargs[i] == "-noconfig" and baseargs[i+1] == "all":
        baseargs = baseargs[:i] + baseargs[i+2:]
        break

    self.player._base_args = baseargs
    ### End of ugly hack. ######################################


    # Fix args.
    self.player.args = ['-msglevel', 'global=6', '-include', '~/.pstorytime/mplayer.conf']

    self.player.stdout.connect(self._handle_stdout)
    self.player.stderr.connect(self._handle_stderr)

    self.player.spawn()

  # Listen for events from mplayer.
  def _handle_stdout(self,data):
    print("stdout: {0}".format(data))
    if data == 'Starting playback...':
      self._startComplete()
    elif data.startswith('EOF code:'):
      self._fileDone()

  def _handle_stderr(self,data):
    print("stderr: {0}".format(data))
    if data == 'Failed to recognize file format.':
      self._fileDone()

  def _fileDone(self):
    self.playing = False
    self.position = 0
    files = self.listFiles()
    try:
      i = files.index(self.file)
      if i+1 < len(files):
        self.file = files[i+1]
        self.play()
      elif len(files) > 0:
        self.file = files[0]
    except ValueError:
      pass

  def _startComplete(self):
    pass

  def _bookfile(self,e):
    return isfile(join(self.book,e))

  def listFiles(self):
    entries = os.listdir(self.book)
    entries.sort()
    files = filter(self._bookfile,entries)
    return files

  def play(self, startfile = None, startposition = None):
    if (not self.playing) or startfile != None or startposition != None:
      self.playing = True

      # Change file
      if startfile != None:
        self.file = startfile

      # Change position
      if startposition != None:
        self.position = startposition
      else:
        pass
        # TODO: Use bookmark

      # Load file if necessary, otherwise unpause if not playing anything.
      if startfile != self.player.filename:
        filename = join(self.book,self.file)
        self.player.loadfile(filename)
      elif self.player.paused:
        self.player.pause()

      # Set position in file.
      self.player.time_pos = self.position

  def pause(self):
    if self.playing:
      self.playing = False
      if not self.player.paused:
        # Pause playback
        self.player.pause()

      # Update bookmark
      pos = self.player.time_pos
      if pos != None:
        self.position = pos
        # TODO: Update bookmark for real.

  def playpause(self):
    if self.playing:
      self.pause()
    else:
      self.play()

  def seek(self,d):
    # Make the seek
    self.player.time_pos = Step(d)

    # Update bookmark
    self.position = self.player.time_pos
    # TODO: Update bookmark for real

  def state(self):
    return  { "playing" :   self.playing
            , "book" :      self.book
            , "file" :      self.file
            , "pos" :       self.player.time_pos
            , "storepos" :  self.position
            , "volume" :    self.player.volume
            }

  def vol(self,v):
    self.player.volume = v

  def dvol(self,dv):
    self.player.volume = Step(dv)

  def fileSkip(self,d):
    i = files.index(self.file)
    if 0 < i+d <= len(files):
      self.file = files[i+d]
      self.play()
    else:
      raise FileSkipException()

  def _load(self):
    filename = join(self.book,self.pstorydatafile)
    try:
      with open(filename,'r') as f:
        data = json.load(f)
    except:
      data = {}
    
    if type(data) != dict:
      data = {}

    return data

  def _save(self,data):
    filename = join(self.book,self.pstorydatafile)
    try:
      with open(filename,'r') as f:
        json.dump(data,f)
    except:
      pass
