#!/usr/bin/env python
import os
import json
from os.path import *

from mplayer import Player, CmdPrefix, PIPE, Step

class SkipFileException(Exception):
  pass

class AudioBook(object):
  def __init__(self,directory):
    self.directory = normcase(expanduser(directory))
    self.curfile = None
    if not isdir(directory):
      e = IOError()
      e.errno = 2
      e.strerror = "No such file or directory"
      e.filename = directory
      raise e

    self.playlogfile = ".pstorylog"

    # TODO: Load play log.
    # TODO: Merge and remove temporary seek and auto save.

    self.playing = False

    # Set up mplayer.
    self.player = Player(stdout=PIPE, stderr=PIPE, autospawn=False)


    ### Beginning of ugly hack. ################################
    baseargs = self.player._base_args

    # "-really-quiet" changed to "-quiet" (needed to spot when mplayer fails to load files.)
    try:
      i = baseargs.index("-really-quiet")
      baseargs = baseargs[:i] + ("-quiet",) + baseargs[i+1:]
    except ValueError:
      pass

    # "-noconfig all" removed all together (we want to use ordinary mplayer config.)
    for i in xrange(0,len(baseargs)-1):
      if baseargs[i] == "-noconfig" and baseargs[i+1] == "all":
        baseargs = baseargs[:i] + baseargs[i+2:]
        break

    self.player._base_args = baseargs
    ### End of ugly hack. ######################################


    # Fix args.
    self.player.args = ['-msglevel', 'global=6', '-include', '~/.pstorytime/mplayer.conf']

    self.player.stdout.connect(self._handle_stdout)
    self.player.stderr.connect(self._handle_stderr)

    self.player.spawn()

  # Listen for events from mplayer.
  def _handle_stdout(self,data):
    print("stdout: {0}".format(data))
    if data == 'Starting playback...':
      self._startComplete()
    elif data.startswith('EOF code:'):
      self._fileDone()

  def _handle_stderr(self,data):
    print("stderr: {0}".format(data))
    if data == 'Failed to recognize file format.':
      self._fileDone()

  def _fileDone(self):
    nextfile = self.getFile(1)
    if nextfile != None:
      self._play(nextfile, log=False)
    else:
      self._endOfBook()

  def _endOfBook(self):
    # TODO: End of book reached.
    pass

  def _startComplete(self):
    pass

  def listFiles(self):
    entries = os.listdir(self.directory)
    entries.sort()
    return filter(lambda e: isfile(join(self.directory,e)),entries)

  def play(self, startfile = None, startposition = None):
    return self._play(startfile,startposition)

  def _play(self, startfile = None, startposition = None, log = True):
    if (not self.playing) or startfile != None or startposition != None:
      self.playing = True

      # Load state from play log
      if startfile == None and self.curfile == None:
        # TODO: Load last file and position from play log.
        pass
      
      # Change file
      if startfile != None:
        self.curfile = startfile
        if startposition == None:
          startposition = 0

      # TODO: Update play log.
      # TODO: Update auto save, start autosaving.

      # Load file if necessary, otherwise unpause if not playing anything.
      if self.curfile != self.player.filename:
        path = join(self.book,self.curfile)
        self.player.loadfile(path)
      elif self.player.paused:
        self.player.pause()
      else:
        assert False ('Invalid state: The correct file is loaded and we are not paused. Why are we trying to start playing?')

      # Set position in file.
      if startposition != None:
        if startposition < -self.player.length:
          # Position is in a file further back
          prevfile = self._getFile(-1)
          if prevfile == None:
            # Start playing where we are, in the beginning of the first file.
            pass
          else:
            self._play(prevfile, self.player.length-startposition)
        elif startposition < 0:
          # Position relative to the end of the file
          self.player.time_pos = self.player.length-startposition
        elif startposition < self.player.length:
          # Position relative to the beginning of the file
          self.player.time_pos = startposition
        else:
          # Position is in a file further on
          nextfile = self._getFile(1)
          if nextfile == None:
            self._endOfBook()
          else:
            self._play(nextfile, startposition-self.player.length)
          


  def pause(self):
    if self.playing:
      self.playing = False
      if not self.player.paused:
        # Pause playback
        self.player.pause()

      # TODO: Update play log.
      # TODO: Remove temporary seek and autosave, stop autosaving.
      #pos = self.player.time_pos

  def playpause(self):
    if self.playing:
      self.pause()
    else:
      self.play()

  def seek(self,d):
    # Make the seek
    self.player.time_pos = Step(d)
    # TODO: Allow seeking across files.

    # TODO: Update play log after a timeout... (In the mean time store in temporary file.)

  def status(self):
    return  { "playing"   : self.playing
            , "directory" : self.directory
            , "curfile"   : self.curfile
            , "position"  : self.player.time_pos
            , "volume"    : self.player.volume
            , "speed"     : self.player.speed
            }

  def vol(self,v):
    self.player.volume = v

  def dvol(self,dv):
    self.player.volume = Step(dv)

  def speed(self,s):
    self.player.speed = s

  def dspeed(self,ds):
    self.player.speed = Step(ds)

  def getFile(self,d):
    try:
      files = self.listFiles()
      i = files.index(self.curfile)
      if 0 < i+d <= len(files):
        return files[i+d]
      else:
        return None
    except ValueError:
      return None

ab = AudioBook("testbook")
